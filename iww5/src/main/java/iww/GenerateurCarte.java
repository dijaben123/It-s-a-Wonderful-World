package iww;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

/**
 * This class contains methods to generate a deck of cards and a list of empires from JSON files.
 * The deck of cards is generated by reading a JSON file containing information about each card,
 * and creating a Carte object for each card. The list of empires is generated by reading a JSON
 * file containing information about each empire, and creating an Empire object for each empire.
 * Both the deck of cards and the list of empires are shuffled before being returned.
 */
public class GenerateurCarte {

    /**
     * Constructs a new instance of the GenerateurCarte class.
     * This class is likely designed to generate or manage game cards.
     * The constructor, as presented, has no explicit initialization or actions.
     */
    public GenerateurCarte(){}

    /**
     * Generates a deck of cards from a JSON file.
     *
     * @return An ArrayList of Carte objects representing the deck of cards.
     */
    public static ArrayList<Carte> genPioche() {
        ArrayList<Carte> pioche = new ArrayList<Carte>();
        String filePath = "cartes.json";
        int index = 0;
        try {
            ObjectMapper objectMapper = new ObjectMapper();
            JsonNode rootNode = objectMapper.readTree(new File(filePath));
            Iterator<String> Cartes = rootNode.fieldNames();
            while (Cartes.hasNext()) {

                String Carte = Cartes.next();
                JsonNode projectNode = rootNode.get(Carte);

                // Récupérez les informations du projet actuel
                String nom = projectNode.get("nom").asText();
                String type = projectNode.get("type").asText();

                JsonNode coutConstructionNode = projectNode.get("coutConstruction");
                JsonNode productionNode = projectNode.get("production");
                JsonNode recyclageNode = projectNode.get("bonusRecyclage");
                JsonNode bonusConstNode = projectNode.get("bonusConstruc");
                JsonNode pointVictoireNode = projectNode.get("pointVictoire");
                LinkedHashMap<String, Integer> coutProd = new LinkedHashMap<String, Integer>();
                LinkedHashMap<String, Integer> bonusConst = new LinkedHashMap<String, Integer>();
                LinkedHashMap<String, Integer> bonusRec = new LinkedHashMap<String, Integer>();
                LinkedHashMap<String, String> production = new LinkedHashMap<String, String>();
                LinkedHashMap<String, Integer> pVictoire = new LinkedHashMap<String, Integer>();
                coutConstructionNode.fields().forEachRemaining(entry -> {
                    String champ = entry.getKey();
                    JsonNode valeur = entry.getValue();
                    coutProd.put(champ, valeur.asInt());
                });
                productionNode.fields().forEachRemaining(entry -> {
                    String champ = entry.getKey();
                    JsonNode valeur = entry.getValue();
                    production.put(champ, valeur.toString());
                });
                recyclageNode.fields().forEachRemaining(entry -> {
                    String champ = entry.getKey();
                    JsonNode valeur = entry.getValue();
                    bonusRec.put(champ, valeur.asInt());
                });
                bonusConstNode.fields().forEachRemaining(entry -> {
                    String champ = entry.getKey();
                    JsonNode valeur = entry.getValue();
                    bonusConst.put(champ, valeur.asInt());
                });
                pointVictoireNode.fields().forEachRemaining(entry -> {
                    String champ = entry.getKey();
                    JsonNode valeur = entry.getValue();
                    pVictoire.put(champ, valeur.asInt());
                });

                pioche.add(new Carte(nom, type, index, coutProd, bonusConst, bonusRec, production, pVictoire));
                index++;
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        Collections.shuffle(pioche);
        return pioche;
    }

    /**
     * This method generates a list of empires from a JSON file.
     * The empires are shuffled before being returned.
     *
     * @return ArrayList of Empire objects
     */
    public static ArrayList<Empire> genCartesEmpire() {
        String filePath = "empires.json";
        ArrayList<Empire> piocheEmpire = new ArrayList<Empire>();
        try {
            ObjectMapper objectMapper = new ObjectMapper();
            JsonNode rootNode = objectMapper.readTree(new File(filePath));
            Iterator<String> Cartes = rootNode.fieldNames();
            while (Cartes.hasNext()) {
                String Carte = Cartes.next();
                JsonNode projectNode = rootNode.get(Carte);

                String nom = projectNode.get("nom").asText();
                JsonNode faceANode = projectNode.get("face A");
                JsonNode ptsVictoireNode = faceANode.get("points de victoire");
                JsonNode productionNode = faceANode.get("production");

                LinkedHashMap<String, Integer> ptsVictoire = new LinkedHashMap<String, Integer>();
                LinkedHashMap<String, Integer> productions = new LinkedHashMap<String, Integer>();
                ptsVictoireNode.fields().forEachRemaining(entry -> {
                    String champ = entry.getKey();
                    JsonNode valeur = entry.getValue();
                    ptsVictoire.put(champ, valeur.asInt());
                });
                productionNode.fields().forEachRemaining(entry -> {
                    String champ = entry.getKey();
                    JsonNode valeur = entry.getValue();
                    productions.put(champ, valeur.asInt());
                });
                piocheEmpire.add(new Empire(nom, ptsVictoire, productions));
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        Collections.shuffle(piocheEmpire);
        return piocheEmpire;
    }

    /**
     * Creates and returns a list of card packs from the given deck.
     *
     * @param pioche The deck of cards from which packs are created.
     * @return An ArrayList containing lists of cards representing card packs.
     */
    public static ArrayList<List<Carte>> creationPaquets(ArrayList<Carte> pioche){
        ArrayList<List<Carte>> paquetsDeCartes = new ArrayList<>();
        System.out.println("pioche"+ pioche.size());
        for (int i = 0; i < 8 ; i++) {
            List<Carte> paquet = new ArrayList<>();
            for (int j = 0; j < 5; j++) {
                paquet.add(pioche.remove(0)); // Retirez la carte de la liste d'origine et ajoutez-la au paquet
            }
            paquetsDeCartes.add(paquet); // Ajoutez le paquet à la liste de paquets
        }
        System.out.println("pioche"+ pioche.size());
        System.out.println("paquetsDeCartes"+ paquetsDeCartes.size());
        return paquetsDeCartes;
    }
}